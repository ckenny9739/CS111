CS 111 - Lab 1B

Partners: Connor Kenny (304437322) and Jusin Liu (504487373)

Implementation:

We used our implementation for lab 1A below as a base and expanded from there.

oflag options: We simply made a bit_mask and OR'd them as the options were called. Then we reset it back to 0 upon open.
rdwr: Same implementation as rdonly and wronly except it is rdwr in the open call.
pipe: We checked to make sure there was space for 2 file descriptors and then called pipe. Then we added those new
      file descriptors to our array. The trickier part is learning how to use the pipes correctly.
wait: We set a wait flag if this option was called. Then at the end of the parent process, we wait for all the child processes
      with the wait(&status) call - could have used waitpid(-1 ...) but it is easier. We want the user to be in charge of close
      all the file descriptors.
      close: We just used the close() call on the file descriptor in our array
      abort: Use raise() to force a segmentation fault.
      catch, ignore, default: We created a very simple signal handler for catch and just used the basic options for ignore
      and default, respectively.
      pause: We called pause.

This implementation should work on all test cases outlined by the spec and TA's. We have chosen to let --close be the method for
avoiding the infinite waiting problem.

Limitations:
No known limitations for Lab 1B

Extra Features:
No Extra Features for Lab 1B

---------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------
CS 111 - Lab 1A

Partners: Connor Kenny (304437322) and Jusin Liu (504487373)

Implementation:

We used an array of option structs to hold each of our 4 viable options. Then using
a while loop we could go through each of the arguments passed to simpsh.
This lead into a switch statement for each of the options. This allowed us to
make sure that each one did the appropriate thing. --rdonly and --wronly simply
open a file to be read or written into. --verbose sets a verbose flag that will
print out the option and arguments each time through the while loop after the flag
is set. Finally, --command's implementation is more complicated. It involves creating
child processes for each command via a fork() call. Then we used dup2() to set the
correct file descriptors (3 calls - 1 for input, 1 for output, 1 for error). Finally,
we used execvp() to actually issue the command. This basically rids us of the child
process (because it has been used up for execvp()) and leaves the main process
to go through the rest of the options.

This implementation should work on all test cases, inlcuding multiple --verbose
options and multiple --command options. 

Limitations:
No known limitations for Lab 1A

Extra Features:
No Extra Features for Lab 1A

